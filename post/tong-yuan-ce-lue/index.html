
<!DOCTYPE html>
<html>
  <head>
    
<meta charset="utf-8" >

<title>同源策略 | AnRan </title>
<meta name="description" content="超人学飞的日子">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://anran1dea.github.io//favicon.ico?v=1569821294513">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://anran1dea.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



  </head>
  <body>
    <div id="app" class="main">
      <div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://anran1dea.github.io/">
        <img class="avatar" src="https://anran1dea.github.io//images/avatar.png?v=1569821294513" alt="" width="32px" height="32px">
      </a>
      <a href="https://anran1dea.github.io/">
        <h1 class="site-title">AnRan </h1>
      </a>
    </div>
    <div class="right">
      <transition name="fade">
        <i class="icon" :class="{ 'icon-close-outline': menuVisible, 'icon-menu-outline': !menuVisible }" @click="menuVisible = !menuVisible"></i>
      </transition>
    </div>
  </div>
</div>

<transition name="fade">
  <div class="menu-container" style="display: none;" v-show="menuVisible">
    <div class="menu-list">
      
        
          <a href="/" class="menu purple-link">
            首页
          </a>
        
      
        
          <a href="/archives" class="menu purple-link">
            归档
          </a>
        
      
        
          <a href="/tags" class="menu purple-link">
            标签
          </a>
        
      
        
          <a href="/post/about" class="menu purple-link">
            关于
          </a>
        
      
    </div>
  </div>
</transition>


      <div class="content-container">
        <div class="post-detail">
          
          <h2 class="post-title">同源策略</h2>
          <div class="post-info post-detail-info">
            <span><i class="icon-calendar-outline"></i> 2019-09-30</span>
            
          </div>
          <div class="post-content">
            <p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。</p>
<!-- more -->
<p>以下请求必须同源</p>
<ol>
<li><strong>以跨站点的方式调用XMLHttpRequest或者Fetch API。</strong></li>
<li><strong>Web字体（用于CSS中@ font-face的跨域字体使用）</strong></li>
<li><strong>WebGL textures</strong></li>
<li><strong>使用drawImage绘制到canvas的图像/视频帧。</strong></li>
<li><strong>样式表（用于CSSOM访问）</strong></li>
</ol>
<h6 id="同源策略有的限制有两种表现">同源策略有的限制有两种表现：</h6>
<p>​	（1）限制发起AJAX请求(XMLHttpRequest，Fetch)；（2）拦截其他跨站请求的返回结果；这取决于请求是否为简单请求。</p>
<p><strong>script中的跨域请求是可以成功发送的，只是浏览器拦截了服务器返回的内容</strong></p>
<h3 id="同源规则">同源规则</h3>
<p>同协议，同主机，同端口</p>
<h3 id="不受同源策略限制">不受同源策略限制</h3>
<h5 id="页面链接重定向表单提交">页面链接，重定向，表单提交</h5>
<h5 id="script-iframe-img-link-标签加载资源">script  iframe, img, link 标签加载资源</h5>
<p>​		都带有SRC属性，每次加载资源相当于一次GET请求</p>
<p>​		浏览器会限制从script内部发起的跨域请求和src属性加载不同</p>
<p>​		<strong>浏览器会限制js的权限使其不能对返回结果进行读写操作</strong></p>
<pre><code>![](https://anran1dea.github.io//post-images/1569818189909.png)
</code></pre>
<p>​</p>
<h1 id="cors跨域资源共享">CORS跨域资源共享</h1>
<p>跨域资源共享（Cross-Origin Resource Sharing, CORS）是一种解决跨域请求的方案，其机制是使用一组额外响应头（Access-Control-Allow-Origin）和预检请求(OPTIONS)来使浏览器有权使用非同源资源。大部分的现代浏览器符合该标准。</p>
<h6 id="cors是一种跨域资源共享方法而不是方法xss的手段">CORS是一种跨域资源共享方法而不是方法XSS的手段</h6>
<h3 id="cors策略允许的跨域共享场景">CORS策略允许的跨域共享场景</h3>
<ul>
<li>由<code>XMLHttpRequest</code>或<code>Fetch</code>等发起的跨域请求；</li>
<li>Web字体，通过@font-face进行跨域调用；</li>
<li>WebGL贴图；</li>
<li>使用 drawImage 将 Images/video 画面绘制到 canvas；</li>
<li>样式表（使用 CSSOM）；</li>
<li>scripts；</li>
</ul>
<h3 id="cors实现条件">CORS实现条件</h3>
<p><code>CORS</code>通过一些特殊的HTTP头来确保哪些源站可以请求哪些资源，除此之外，如果这个请求会对服务器的数据产生<code>修改的可能</code>将会在跨域之前发起一个<code>preflight</code>请求进行检查，如果检查不通过，那么不会发起跨域请求。</p>
<p><strong>并不是所有的请求都会触发<code>preflight</code>机制，这些不会触发<code>preflight</code>的请求被称为<code>simple request</code>。</strong></p>
<h3 id="简单请求simple-request条件">简单请求(Simple Request)条件</h3>
<ul>
<li>
<p>GET请求</p>
</li>
<li>
<p>HEAD请求</p>
</li>
<li>
<p>Content-Type为指定值的POST请求，</p>
<ul>
<li><code>text/plain</code></li>
<li><code>multipart/form-data</code></li>
<li><code>application/x-www-form-urlencode</code></li>
</ul>
<p>（备注：若使用jquery的ajax发送请求，没指定<code>Content-Type</code>的情况下，默认它的值是<code>application/x-www-form-urlencoded</code>。源生的ajax请求请手动显示指定）</p>
</li>
<li>
<p>HTTP首部字段不能包含下列以外的值：</p>
</li>
<li>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
</ul>
<h3 id="简单请求过程">简单请求过程</h3>
<p>对于这种请求，浏览器是<strong>直接</strong>发出请求，它的特点是：浏览器自动给加上一个<code>Origin</code>的请求头，表示这个请求的来源（来自哪个源）, 服务端可拿到这个<code>Origin</code>源，然后判断服务端是否能够接受这个源从而决定是否同意这次请求（不同意or同意）：</p>
<ul>
<li>
<p>不同意：服务器会返回一个<strong>正常的</strong>HTTP回应（响应头里木有<code>Access-Control-Allow-Origin</code>），浏览器发现木有这个头，就抛出一个错误<code>XMLHttpRequest</code>，进而进入ajax的<code>onerror</code>回到方法里（<strong>这就是为何你明明看到http状态码是200，response也有返回值，但偏偏你ajax里就是进入的error的原因~</strong>），它的现象是：服务器正常返回了资源，但浏览器拒绝接收了。</p>
</li>
<li>
<p>同意：服务器的响应里会多出下面详解的几个响应头，从而回调ajax的onsuccess方法，这就是真正意义上的成功了，浏览器也接收了这个返回结果。</p>
<h5 id="和简单请求相关的3个响应头">和简单请求相关的3个响应头</h5>
<h6 id="access-control-allow-origin">Access-Control-Allow-Origin</h6>
<p>该响应头是服务器<strong>必须</strong>返回的。它的值要么是请求时<code>Origin</code>的值（可从request里获取），要么是<code>*</code>这样浏览器才会接受服务器的返回结果。</p>
<h6 id="access-control-allow-credentials">Access-Control-Allow-Credentials</h6>
<p>该响应头非必须，值是bool类型，表示是否允许发送<code>Cookie</code></p>
<ul>
<li>true：表示服务器允许你浏览器把cookie发给我（若服务器想获取Cookie的，请务必设置此值）</li>
<li><s>false</s> ：请注意此字段只能设置为true，若不允许发送<code>cookie</code>，不要设置此响应头即可</li>
<li>如果请求需要带cookie，该header必须为true，同时Access-Control-Allow-Origin不能为*，否则同样拿不到结果；</li>
</ul>
<h6 id="access-control-expose-headers">Access-Control-Expose-Headers</h6>
<p>该响应头非必须。顾名思义它要把response中的哪些头暴露给浏览器，让它可以获取到（默认情况下浏览器的XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能获取到那些<code>Cache-Control、Expires等等</code>几个标准的响应头，若需要拿其它key，需要在这里指定）</p>
</li>
</ul>
<h3 id="预检请求">预检请求</h3>
<p>在发起跨域请求前，预先发起一个<code>OPTIONS</code>请求进行检查。在<code>preflight request</code>的返回头中，会包含一些关于是否允许发起跨域的信息，服务器允许后才能发送实际请求（可以猜想这是为了防止CSRF）。</p>
<h5 id="请求头">请求头：</h5>
<ul>
<li>
<p><code>Origin</code>：<origin>：表示实际请求的源站</p>
</li>
<li>
<p><code>Access-Control-Request-Method</code>: <method>：用于预检请求，表示接下来<strong>真实</strong>的请求方法。</p>
</li>
<li>
<p><code>Access-Control-Request-Headers</code>: <field-name>[, <field-name>]*：用于预检请求，表示<strong>真实</strong>请求所携带的首部字段（从抓包上来看chrome没有按要求来啊Orz）</p>
<p><strong>相应头</strong></p>
</li>
<li>
<p><code>Access-Control-Allow-Origin</code>: <origin> | *：允许外域URI</p>
</li>
<li>
<p><code>Access-Control-Allow-Methods</code>：用于预检请求响应，表示允许使用的HTTP方法</p>
</li>
<li>
<p><code>Access-Control-Allow-Headers</code>：用于预检请求响应，表示允许携带的头部</p>
</li>
<li>
<p><code>Access-Control-Expose-Headers</code>：允许响应时能获取的其他头部（在跨域访问时，XMLHttpRequest对象的getResponseHeader()方法只能拿到一些最基本的响应头）</p>
</li>
<li>
<p><code>Access-Control-Allow-Credentials</code>：false：是否允许浏览器读取response内容（如cookie）</p>
</li>
<li>
<p><code>Access-Control-Max-Age</code>：preflight请求的最大响应时间</p>
</li>
</ul>
<blockquote>
<p><strong>如果发起的是一个简单请求，那么不会经过<code>preflight</code>，但是有一点需要注意，如果服务端返回的信息中没有<code>Access-Control-Allow-Credentials: true</code>，浏览器就会拦截返回内容，不会将内容返还给调用者。</strong></p>
</blockquote>
<p><a href="https://www.freebuf.com/articles/web/195925.html">https://www.freebuf.com/articles/web/195925.html</a></p>
<p><a href="https://www.secpulse.com/archives/63801.html">https://www.secpulse.com/archives/63801.html</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1513418">https://cloud.tencent.com/developer/article/1513418</a></p>
<h1 id="jsonp跨域共享">JSONP跨域共享</h1>
<p>利用了使用src引用静态资源时不受跨域限制的机制。主要在客户端搞一个回调做一些参数接收与操作的处理，并把这个回调函数告知服务器，而服务器端需要做的是按照JavaScript的语法把数据放到约定好的回调函数之中即可，jQuery很早之前就已经把JSONP语法糖化了，使用起来会更加方便。</p>
<h3 id="原生js具体实现">原生JS具体实现</h3>
<p>前端请求</p>
<pre><code class="language-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
    // 得到航班信息查询结果后的回调函数
    var flightHandler = function(data){
        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
    };
    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）
    var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;;
    // 创建script标签，设置其属性
    var script = document.createElement('script');
    script.setAttribute('src', url);
    // 把script标签加入head，此时调用开始
    document.getElementsByTagName('head')[0].appendChild(script); 
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;    
&lt;/html&gt;
</code></pre>
<p>服务端返回</p>
<pre><code class="language-json">flightHandler({
    &quot;code&quot;: &quot;CA1998&quot;,
    &quot;price&quot;: 1780,
    &quot;tickets&quot;: 5
});
</code></pre>
<h3 id="jquery实现">JQuery实现</h3>
<p>前端请求</p>
<pre><code class="language-html">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt;
&lt;head&gt;
     &lt;title&gt;Untitled Page&lt;/title&gt;
      &lt;script type=&quot;text/javascript&quot; src=“jquery.min.js&quot;&gt;
      &lt;script type=&quot;text/javascript&quot;&gt;
     jQuery(document).ready(function(){ 
        $.ajax({
             type: &quot;get&quot;,
             async: false,
             url: &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;,
             dataType: &quot;jsonp&quot;,
             jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
             jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据
             success: function(json){
                 alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。');
             },
             error: function(){
                 alert('fail');
             }
         });
     });
     &lt;/script&gt;
     &lt;/head&gt;
  &lt;body&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>jquery在处理jsonp类型的ajax时（虽然jquery也把jsonp归入了ajax，但不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用</p>
</blockquote>
<p><a href="https://www.cnblogs.com/rain-chenwei/p/9520240.html">https://www.cnblogs.com/rain-chenwei/p/9520240.html</a></p>
<p><a href="https://blog.csdn.net/hansexploration/article/details/80314948">https://blog.csdn.net/hansexploration/article/details/80314948</a></p>
<h3 id="jsonp和cors的优缺点">JSONP和CORS的优缺点</h3>
<ol>
<li>JSONP的主要优势在于对浏览器的支持较好；虽然目前主流浏览器都支持CORS，但IE9及以下不支持CORS。</li>
<li>**JSONP只能用于获取资源（即只读，类似于GET请求）；CORS支持所有类型的HTTP请求，**功能完善.<br>
JSONP的错误处理机制并不完善，我们没办法进行错误处理；而CORS可以通过onerror事件监听错误，并且浏览器控制台会看到报错信息，利于排查。</li>
<li>JSONP只会发一次请求；而对于复杂请求，CORS会发两次请求。</li>
<li>始终觉得安全性这个东西是相对的，没有绝对的安全，也做不到绝对的安全。毕竟JSONP并不是跨域规范，它存在很明显的安全问题：<strong>callback参数注入和资源访问授权设置</strong>。<strong>CORS好歹也算是个跨域规范，在资源访问授权方面进行了限制（Access-Control-Allow-Origin），而且标准浏览器都做了安全限制</strong>，比如拒绝手动设置origin字段，相对来说是安全了一点。但是回过头来看一下，就算是不安全的JSONP，我们依然可以在服务端端进行一些权限的限制，服务端和客户端也都依然可以做一些注入的安全处理，哪怕被攻克，它也只能读一些东西。就算是比较安全的CORS，同样可以在服务端设置出现漏洞或者不在浏览器的跨域限制环境下进行攻击，而且它不仅可以读，还可以写。</li>
</ol>

          </div>
        </div>

        
          <div class="next-post">
            <a class="purple-link" href="https://anran1dea.github.io//post/hello-gridea">
              <h3 class="post-title">
                下一篇：Hello Gridea
              </h3>
            </a>
          </div>
          
      </div>

      

      <div class="site-footer">
  <div class="slogan">超人学飞的日子</div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
   | <a class="rss" href="https://anran1dea.github.io//atom.xml" target="_blank">RSS</a>
</div>


    </div>
    <script type="application/javascript">

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
